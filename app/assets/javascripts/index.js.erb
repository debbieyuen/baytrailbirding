// ESLINT:
/* global L, moment, $ */

'use strict';

const MAX_RADIUS = 50;	// Radius distance in miles

const Unit = {
	mi2km: mi => mi * 1.609,
	mi2m: mi => Unit.mi2km(mi) * 1000,
	km2mi: km => km / 1.609,
	m2mi: m => Unit.km2mi(m / 1000)
};

class Ebird {
	static getBirds(lat, lng, radius) {
		const request = {
			url: '/ebird/birds',
			method: 'GET',
			data: {
				lat,
				lng,
				radius
			}
		};

		return new Promise(resolve => {
			$.ajax(request).done(birds => {
				birds.forEach(bird => {
					bird.obs.date = new Date(bird.obs.date);
					bird.loc.latLng = L.latLng(bird.loc.lat, bird.loc.lng);
				});
				resolve(birds);
			});
		});
	}

	static getHotspots(lat, lng, radius) {
		const request = {
			url: '/ebird/hotspots',
			method: 'GET',
			data: {
				lat,
				lng,
				radius
			}
		};

		return new Promise(resolve => {
			$.ajax(request).done(hotspots => {
				hotspots.forEach(hotspot => {
					hotspot.obs.date = new Date(hotspot.obs.date);
					hotspot.loc.latLng = L.latLng(hotspot.loc.lat, hotspot.loc.lng);
				});
				resolve(hotspots);
			});
		});
	}
}

class BirdMap {
	constructor(elementId, currentPosition) {

		const tileLayerSource = 'https://a.tiles.mapbox.com/styles/v1/lohneswright/ciocejooj006obdnjhmd2x9qp/tiles/{z}/{x}/{y}?access_token={accessToken}';

		const map = L.map(elementId).setView([37.42, -121.91], 13);

		L.tileLayer(tileLayerSource, {
			maxZoom: 22,
			accessToken: 'pk.eyJ1IjoibG9obmVzd3JpZ2h0IiwiYSI6IngzbVlqNnMifQ.OwxjrBKoGXc60NB5x6GKzw',
			attribution: '<a href="http://jawg.io" title="Tiles Courtesy of Jawg Maps" target="_blank">&copy; <b>Jawg</b>Maps</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
		}).addTo(map);

		this.map = map;

		this.icon = {
			bird: {
				selected: L.divIcon({
					html: '<i class="fa-solid fa-dove fa-2x"></i>',
					iconSize: [20, 20],
					className: 'bird-icon-selected'
				}),
				marker: L.divIcon({
					html: '<i class="fa-solid fa-dove fa-2x"></i>',
					iconSize: [20, 20],
					className: 'bird-icon'
				})
			},
			hotspot: {
				selected: L.divIcon({
					html: '<i class="fa-solid fa-binoculars fa-2x"></i>',
					iconSize: [20, 20],
					className: 'hotspot-icon-selected'
				}),
				marker: L.divIcon({
					html: '<i class="fa-solid fa-binoculars fa-2x"></i>',
					iconSize: [20, 20],
					className: 'hotspot-icon'
				})
			},
			location: {
				selected: L.divIcon({
					html: 'TODO',
					iconSize: [20, 20],
					className: 'bird-icon-selected'
				}),
				marker: L.divIcon({
					html: 'TODO',
					iconSize: [20, 20],
					className: 'bird-icon'
				})
			}
		}

		this.position = currentPosition;

		this.map.panTo(currentPosition);

		const km = MAX_RADIUS * 1000;

		const m = Math.floor(km * Math.sqrt(2));

		const bounds = currentPosition.toBounds(m);

		this.map.once('moveend', () => {
			this.map.setMinZoom(this.map.getZoom());

			this.birds = L.markerClusterGroup();
			this.hotspots = L.markerClusterGroup();
			this.locations = L.markerClusterGroup();

			this.markers = L.layerGroup([this.birds, this.hotspots, this.locations]);

			this.markers.on('clusterclick', () => {
				if (this.selected) this.selected.setIcon(this.selected.defaultIcon);
				$('.overlay').attr('hidden', '');
			});

			this.selected = null;

			this.map.on('moveend', () => {
				this.load();
			});

			this.map.addLayer(this.birds);
			this.map.addLayer(this.hotspots);
			this.map.addLayer(this.locations);

			this.load();
		});

		this.map.fitBounds(bounds);
	}

	async loadBirds() {
		const {
			lat, lng
		} = this.getCurrPosition();
		const birds = await Ebird.getBirds(lat, lng, this.getRadius());
		const bounds = this.map.getBounds();
		const markers = birds
			.filter(bird => bounds.contains(bird.loc.latLng))
			.map(bird => this.createBird(bird.loc.latLng, bird));

		markers.forEach(marker => {
			const isNearHotspot = this.hotspots.getLayers().find(hotspotMarker => hotspotMarker.getLatLng().equals(marker.getLatLng()));
			const alreadyExists = this.birds.getLayers().find(mapMarker => mapMarker.birdId === marker.birdId);
			if (!alreadyExists && !isNearHotspot) this.birds.addLayer(marker);
		});
	}

	async loadHotspots() {
		const {
			lat, lng
		} = this.getCurrPosition();
		const hotspots = await Ebird.getHotspots(lat, lng, this.getRadius());
		const bounds = this.map.getBounds();
		const markers = hotspots
			.filter(hotspot => bounds.contains(hotspot.loc.latLng))
			.map(hotspot => this.createHotspot(hotspot.loc.latLng, hotspot));

		markers.forEach(marker => {
			const alreadyExists = this.hotspots.getLayers().find(mapMarker => mapMarker.locId === marker.locId);
			if (!alreadyExists) this.hotspots.addLayer(marker);
		});
	}

	async loadLocations() {
		// Right now does not load anything
	}

	async load() {
		await this.loadHotspots();

		await this.loadLocations();

		await this.loadBirds();
	}

	createMarker(latLng, icon, selectIcon) {
		const marker = L.marker(latLng, {
			icon,
			riseOnHover: true
		});

		marker.defaultIcon = icon;

		marker.on('click', () => {
			const position = marker.getLatLng();
			if (this.selected) this.selected.setIcon(icon);
			this.selected = marker;
			this.selected.setIcon(selectIcon);
			this.setCurrPosition(position);
		});

		return marker;
	}

	createBird(latLng, bird) {
		const marker = this.createMarker(latLng, this.icon.bird.marker, this.icon.bird.selected);

		marker.birdId = bird.subId;

		marker.on('click', () => {
			$('.overlay')
				.html(`
					<div class="expand-icon"></div>
					<div class="content">
						<div class="bird-name">${bird.name.com}</div>
						<div class="science-name">${bird.name.sci}</div>
						<div class="bird-img-wrapper">
							<img class="bird-img" src="/duck.png">
						</div>
						<div class="location-wrapper">
							<div class="location">Loc</div>
							<div class="separator"><i class="fa-solid fa-circle"></i></div>
							<div class="distance">${Unit.m2mi(marker.getLatLng().distanceTo(this.position)).toFixed(2)} mi</div>
						</div>
						<div class="description-wrapper">
							<div class="description-header">Description:</div>
							<div class="description-content">No Description Available</div>
					</div>
					</div>
				`)
				.removeAttr('hidden');
		});

		return marker;
	}

	createHotspot(latLng, hotspot) {
		const marker = this.createMarker(latLng, this.icon.hotspot.marker, this.icon.hotspot.selected);

		marker.locId = hotspot.loc.id;

		marker.on('click', () => {
			console.log(hotspot);
		});

		return marker;
	}

	createLocation(latLng, location) {
		// TODO
	}

	setCurrPosition(latLng) {
		this.map.panToOffset(latLng, [window.innerWidth / 4, 0]);
	}

	getCurrPosition() {
		return this.map.getCenter();
	}

	getRadius() {
		const bounds = this.map.getBounds();
		const ne = bounds.getNorthEast();
		const nw = bounds.getNorthWest();
		const m = nw.distanceTo(ne);
		const km = m / 1000;
		const r = Math.min(Math.ceil(km / Math.sqrt(2)), MAX_RADIUS);

		return r;
	}
}

class GPS {
	constructor() {
		this.watchId = null;
	}

	getCurrentPosition(defaultLat, defaultLng) {
		const defaultPosition = L.latLng(defaultLat, defaultLng);

		const options = {
			enableHighAccuracy: true,
			timeout: 5000,
			maximumAge: 0
		};

		return new Promise(resolve => {
			navigator.geolocation.getCurrentPosition(
				position => {
					const {
						coords
					} = position;
					const {
						latitude, longitude
					} = coords;

					resolve(L.latLng(latitude, longitude));
				},
				() => resolve(defaultPosition),
				options
			);
		});
	}

	watchCurrentPosition(onPosChange) {
		const defaultPosition = L.latLng(defaultLat, defaultLng);

		const options = {
			enableHighAccuracy: true,
			timeout: 5000,
			maximumAge: 0
		};

		const watchId = navigator.geolocation.watchPosition(
			position => {
				const {
					coords
				} = position;
				const {
					latitude, longitude
				} = coords;

				onPosChange(L.latLng(latitude, longitude));
			},
			() => onPosChange(defaultPosition),
			options
		);
		this.watchId = watchId;

		return watchId;
	}

	clearWatchCurrentPosition() {
		if (!this.watchId) throw new Error('Not currently watching position');

		navigator.geolocation.clearWatch(this.watchId);

		this.watchId = null;
	}
}

let mymap = null;
let gps = null;

window.addEventListener('load', async () => {
	L.Map.prototype.panToOffset = function(latlng, offset, options) {
		const x = this.latLngToContainerPoint(latlng).x - offset[0];
		const y = this.latLngToContainerPoint(latlng).y - offset[1];
		const point = this.containerPointToLatLng([x, y]);
		return this.setView(point, this.getZoom(), {
			pan: options
		});
	};

	gps = new GPS();
	mymap = new BirdMap('leaflet-map', await gps.getCurrentPosition(37.8039, -122.2591));
});
